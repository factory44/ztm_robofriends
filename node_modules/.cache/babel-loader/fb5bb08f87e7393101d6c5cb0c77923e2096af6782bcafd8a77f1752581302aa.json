{"ast":null,"code":"/**\n * This splits a string on a top-level character.\n *\n * Regex doesn't support recursion (at least not the JS-flavored version).\n * So we have to use a tiny state machine to keep track of paren placement.\n *\n * Expected behavior using commas:\n * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)\n *       ─┬─             ┬  ┬    ┬\n *        x              x  x    ╰──────── Split because top-level\n *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens\n *\n * @param {string} input\n * @param {string} separator\n */\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n  enumerable: true,\n  get: () => splitAtTopLevelOnly\n});\nfunction splitAtTopLevelOnly(input, separator) {\n  let stack = [];\n  let parts = [];\n  let lastPos = 0;\n  for (let idx = 0; idx < input.length; idx++) {\n    let char = input[idx];\n    if (stack.length === 0 && char === separator[0]) {\n      if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {\n        parts.push(input.slice(lastPos, idx));\n        lastPos = idx + separator.length;\n      }\n    }\n    if (char === \"(\" || char === \"[\" || char === \"{\") {\n      stack.push(char);\n    } else if (char === \")\" && stack[stack.length - 1] === \"(\" || char === \"]\" && stack[stack.length - 1] === \"[\" || char === \"}\" && stack[stack.length - 1] === \"{\") {\n      stack.pop();\n    }\n  }\n  parts.push(input.slice(lastPos));\n  return parts;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","splitAtTopLevelOnly","input","separator","stack","parts","lastPos","idx","length","char","slice","push","pop"],"sources":["/Users/grzegorzlis/Visual_Projects/ztm_web_dev/folder17/robofriends/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"],"sourcesContent":["/**\n * This splits a string on a top-level character.\n *\n * Regex doesn't support recursion (at least not the JS-flavored version).\n * So we have to use a tiny state machine to keep track of paren placement.\n *\n * Expected behavior using commas:\n * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)\n *       ─┬─             ┬  ┬    ┬\n *        x              x  x    ╰──────── Split because top-level\n *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens\n *\n * @param {string} input\n * @param {string} separator\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n    enumerable: true,\n    get: ()=>splitAtTopLevelOnly\n});\nfunction splitAtTopLevelOnly(input, separator) {\n    let stack = [];\n    let parts = [];\n    let lastPos = 0;\n    for(let idx = 0; idx < input.length; idx++){\n        let char = input[idx];\n        if (stack.length === 0 && char === separator[0]) {\n            if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {\n                parts.push(input.slice(lastPos, idx));\n                lastPos = idx + separator.length;\n            }\n        }\n        if (char === \"(\" || char === \"[\" || char === \"{\") {\n            stack.push(char);\n        } else if (char === \")\" && stack[stack.length - 1] === \"(\" || char === \"]\" && stack[stack.length - 1] === \"[\" || char === \"}\" && stack[stack.length - 1] === \"{\") {\n            stack.pop();\n        }\n    }\n    parts.push(input.slice(lastPos));\n    return parts;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAI,YAAY;;AAChBA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,qBAAqB,EAAE;EAClDE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAEA,CAAA,KAAIC;AACb,CAAC,CAAC;AACF,SAASA,mBAAmBA,CAACC,KAAK,EAAEC,SAAS,EAAE;EAC3C,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,OAAO,GAAG,CAAC;EACf,KAAI,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGL,KAAK,CAACM,MAAM,EAAED,GAAG,EAAE,EAAC;IACvC,IAAIE,IAAI,GAAGP,KAAK,CAACK,GAAG,CAAC;IACrB,IAAIH,KAAK,CAACI,MAAM,KAAK,CAAC,IAAIC,IAAI,KAAKN,SAAS,CAAC,CAAC,CAAC,EAAE;MAC7C,IAAIA,SAAS,CAACK,MAAM,KAAK,CAAC,IAAIN,KAAK,CAACQ,KAAK,CAACH,GAAG,EAAEA,GAAG,GAAGJ,SAAS,CAACK,MAAM,CAAC,KAAKL,SAAS,EAAE;QAClFE,KAAK,CAACM,IAAI,CAACT,KAAK,CAACQ,KAAK,CAACJ,OAAO,EAAEC,GAAG,CAAC,CAAC;QACrCD,OAAO,GAAGC,GAAG,GAAGJ,SAAS,CAACK,MAAM;MACpC;IACJ;IACA,IAAIC,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;MAC9CL,KAAK,CAACO,IAAI,CAACF,IAAI,CAAC;IACpB,CAAC,MAAM,IAAIA,IAAI,KAAK,GAAG,IAAIL,KAAK,CAACA,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,IAAIC,IAAI,KAAK,GAAG,IAAIL,KAAK,CAACA,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,IAAIC,IAAI,KAAK,GAAG,IAAIL,KAAK,CAACA,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MAC9JJ,KAAK,CAACQ,GAAG,EAAE;IACf;EACJ;EACAP,KAAK,CAACM,IAAI,CAACT,KAAK,CAACQ,KAAK,CAACJ,OAAO,CAAC,CAAC;EAChC,OAAOD,KAAK;AAChB"},"metadata":{},"sourceType":"script","externalDependencies":[]}