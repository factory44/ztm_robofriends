{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: () => expandApplyAtRules\n});\nconst _postcss = /*#__PURE__*/_interopRequireDefault(require(\"postcss\"));\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _generateRules = require(\"./generateRules\");\nconst _escapeClassName = /*#__PURE__*/_interopRequireDefault(require(\"../util/escapeClassName\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */\nfunction extractClasses(node) {\n  /** @type {Map<string, Set<string>>} */let groups = new Map();\n  let container = _postcss.default.root({\n    nodes: [node.clone()]\n  });\n  container.walkRules(rule => {\n    (0, _postcssSelectorParser.default)(selectors => {\n      selectors.walkClasses(classSelector => {\n        let parentSelector = classSelector.parent.toString();\n        let classes = groups.get(parentSelector);\n        if (!classes) {\n          groups.set(parentSelector, classes = new Set());\n        }\n        classes.add(classSelector.value);\n      });\n    }).processSync(rule.selector);\n  });\n  let normalizedGroups = Array.from(groups.values(), classes => Array.from(classes));\n  let classes = normalizedGroups.flat();\n  return Object.assign(classes, {\n    groups: normalizedGroups\n  });\n}\nlet selectorExtractor = (0, _postcssSelectorParser.default)();\n/**\n * @param {string} ruleSelectors\n */\nfunction extractSelectors(ruleSelectors) {\n  return selectorExtractor.astSync(ruleSelectors);\n}\nfunction extractBaseCandidates(candidates, separator) {\n  let baseClasses = new Set();\n  for (let candidate of candidates) {\n    baseClasses.add(candidate.split(separator).pop());\n  }\n  return Array.from(baseClasses);\n}\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction* pathToRoot(node) {\n  yield node;\n  while (node.parent) {\n    yield node.parent;\n    node = node.parent;\n  }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */\nfunction shallowClone(node) {\n  let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let children = node.nodes;\n  node.nodes = [];\n  let tmp = node.clone(overrides);\n  node.nodes = children;\n  return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */\nfunction nestedClone(node) {\n  for (let parent of pathToRoot(node)) {\n    if (node === parent) {\n      continue;\n    }\n    if (parent.type === \"root\") {\n      break;\n    }\n    node = shallowClone(parent, {\n      nodes: [node]\n    });\n  }\n  return node;\n}\n/**\n * @param {import('postcss').Root} root\n */\nfunction buildLocalApplyCache(root, context) {\n  /** @type {ApplyCache} */let cache = new Map();\n  root.walkRules(rule => {\n    // Ignore rules generated by Tailwind\n    for (let node of pathToRoot(rule)) {\n      var _node_raws_tailwind;\n      if (((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.layer) !== undefined) {\n        return;\n      }\n    }\n    // Clone what's required to represent this singular rule in the tree\n    let container = nestedClone(rule);\n    let sort = context.offsets.create(\"user\");\n    for (let className of extractClasses(rule)) {\n      let list = cache.get(className) || [];\n      cache.set(className, list);\n      list.push([{\n        layer: \"user\",\n        sort,\n        important: false\n      }, container]);\n    }\n  });\n  return cache;\n}\n/**\n * @returns {ApplyCache}\n */\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue;\n    }\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(candidate, context.classCache.get(candidate).map(_ref => {\n        let [meta, rule] = _ref;\n        return [meta, rule.clone()];\n      }));\n      continue;\n    }\n    let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n    context.applyClassCache.set(candidate, matches);\n  }\n  return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */\nfunction lazyCache(buildCacheFn) {\n  let cache = null;\n  return {\n    get: name => {\n      cache = cache || buildCacheFn();\n      return cache.get(name);\n    },\n    has: name => {\n      cache = cache || buildCacheFn();\n      return cache.has(name);\n    }\n  };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */\nfunction combineCaches(caches) {\n  return {\n    get: name => caches.flatMap(cache => cache.get(name) || []),\n    has: name => caches.some(cache => cache.has(name))\n  };\n}\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g);\n  if (candidates[candidates.length - 1] === \"!important\") {\n    return [candidates.slice(0, -1), true];\n  }\n  return [candidates, false];\n}\nfunction processApply(root, context, localCache) {\n  let applyCandidates = new Set();\n  // Collect all @apply rules and candidates\n  let applies = [];\n  root.walkAtRules(\"apply\", rule => {\n    let [candidates] = extractApplyCandidates(rule.params);\n    for (let util of candidates) {\n      applyCandidates.add(util);\n    }\n    applies.push(rule);\n  });\n  // Start the @apply process if we have rules with @apply in them\n  if (applies.length === 0) {\n    return;\n  }\n  // Fill up some caches!\n  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);\n  /**\n  * When we have an apply like this:\n  *\n  * .abc {\n  *    @apply hover:font-bold;\n  * }\n  *\n  * What we essentially will do is resolve to this:\n  *\n  * .abc {\n  *    @apply .hover\\:font-bold:hover {\n  *      font-weight: 500;\n  *    }\n  * }\n  *\n  * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n  * What happens in this function is that we prepend a `.` and escape the candidate.\n  * This will result in `.hover\\:font-bold`\n  * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n  *\n  * @param {string} selector\n  * @param {string} utilitySelectors\n  * @param {string} candidate\n  */\n  function replaceSelector(selector, utilitySelectors, candidate) {\n    let selectorList = extractSelectors(selector);\n    let utilitySelectorsList = extractSelectors(utilitySelectors);\n    let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);\n    let candidateClass = candidateList.nodes[0].nodes[0];\n    selectorList.each(sel => {\n      /** @type {Set<import('postcss-selector-parser').Selector>} */let replaced = new Set();\n      utilitySelectorsList.each(utilitySelector => {\n        let hasReplaced = false;\n        utilitySelector = utilitySelector.clone();\n        utilitySelector.walkClasses(node => {\n          if (node.value !== candidateClass.value) {\n            return;\n          }\n          // Don't replace multiple instances of the same class\n          // This is theoretically correct but only partially\n          // We'd need to generate every possible permutation of the replacement\n          // For example with `.foo + .foo { â€¦ }` and `section { @apply foo; }`\n          // We'd need to generate all of these:\n          // - `.foo + .foo`\n          // - `.foo + section`\n          // - `section + .foo`\n          // - `section + section`\n          if (hasReplaced) {\n            return;\n          }\n          // Since you can only `@apply` class names this is sufficient\n          // We want to replace the matched class name with the selector the user is using\n          // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`\n          node.replaceWith(...sel.nodes.map(node => node.clone()));\n          // Record that we did something and we want to use this new selector\n          replaced.add(utilitySelector);\n          hasReplaced = true;\n        });\n      });\n      // Sort tag names before class names (but only sort each group (separated by a combinator)\n      // separately and not in total)\n      // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`\n      for (let sel1 of replaced) {\n        let groups = [[]];\n        for (let node of sel1.nodes) {\n          if (node.type === \"combinator\") {\n            groups.push(node);\n            groups.push([]);\n          } else {\n            let last = groups[groups.length - 1];\n            last.push(node);\n          }\n        }\n        sel1.nodes = [];\n        for (let group of groups) {\n          if (Array.isArray(group)) {\n            group.sort((a, b) => {\n              if (a.type === \"tag\" && b.type === \"class\") {\n                return -1;\n              } else if (a.type === \"class\" && b.type === \"tag\") {\n                return 1;\n              } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n                return -1;\n              } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n                return 1;\n              }\n              return 0;\n            });\n          }\n          sel1.nodes = sel1.nodes.concat(group);\n        }\n      }\n      sel.replaceWith(...replaced);\n    });\n    return selectorList.toString();\n  }\n  let perParentApplies = new Map();\n  // Collect all apply candidates and their rules\n  for (let apply of applies) {\n    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];\n    perParentApplies.set(apply.parent, [candidates, apply.source]);\n    let [applyCandidates1, important] = extractApplyCandidates(apply.params);\n    if (apply.parent.type === \"atrule\") {\n      if (apply.parent.name === \"screen\") {\n        let screenType = apply.parent.params;\n        throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates1.map(c => `${screenType}:${c}`).join(\" \")} instead.`);\n      }\n      throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n    }\n    for (let applyCandidate of applyCandidates1) {\n      if ([prefix(context, \"group\"), prefix(context, \"peer\")].includes(applyCandidate)) {\n        // TODO: Link to specific documentation page with error code.\n        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n      }\n      if (!applyClassCache.has(applyCandidate)) {\n        throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n      }\n      let rules = applyClassCache.get(applyCandidate);\n      candidates.push([applyCandidate, important, rules]);\n    }\n  }\n  for (let [parent, [candidates1, atApplySource]] of perParentApplies) {\n    let siblings = [];\n    for (let [applyCandidate1, important1, rules1] of candidates1) {\n      let potentialApplyCandidates = [applyCandidate1, ...extractBaseCandidates([applyCandidate1], context.tailwindConfig.separator)];\n      for (let [meta, node] of rules1) {\n        let parentClasses = extractClasses(parent);\n        let nodeClasses = extractClasses(node);\n        // When we encounter a rule like `.dark .a, .b { â€¦ }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n        // So we've split them into groups\n        nodeClasses = nodeClasses.groups.filter(classList => classList.some(className => potentialApplyCandidates.includes(className))).flat();\n        // Add base utility classes from the @apply node to the list of\n        // classes to check whether it intersects and therefore results in a\n        // circular dependency or not.\n        //\n        // E.g.:\n        // .foo {\n        //   @apply hover:a; // This applies \"a\" but with a modifier\n        // }\n        //\n        // We only have to do that with base classes of the `node`, not of the `parent`\n        // E.g.:\n        // .hover\\:foo {\n        //   @apply bar;\n        // }\n        // .bar {\n        //   @apply foo;\n        // }\n        //\n        // This should not result in a circular dependency because we are\n        // just applying `.foo` and the rule above is `.hover\\:foo` which is\n        // unrelated. However, if we were to apply `hover:foo` then we _did_\n        // have to include this one.\n        nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n        let intersects = parentClasses.some(selector => nodeClasses.includes(selector));\n        if (intersects) {\n          throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate1}\\` utility here because it creates a circular dependency.`);\n        }\n        let root1 = _postcss.default.root({\n          nodes: [node.clone()]\n        });\n        // Make sure every node in the entire tree points back at the @apply rule that generated it\n        root1.walk(node => {\n          node.source = atApplySource;\n        });\n        let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n        if (canRewriteSelector) {\n          root1.walkRules(rule => {\n            // Let's imagine you have the following structure:\n            //\n            // .foo {\n            //   @apply bar;\n            // }\n            //\n            // @supports (a: b) {\n            //   .bar {\n            //     color: blue\n            //   }\n            //\n            //   .something-unrelated {}\n            // }\n            //\n            // In this case we want to apply `.bar` but it happens to be in\n            // an atrule node. We clone that node instead of the nested one\n            // because we still want that @supports rule to be there once we\n            // applied everything.\n            //\n            // However it happens to be that the `.something-unrelated` is\n            // also in that same shared @supports atrule. This is not good,\n            // and this should not be there. The good part is that this is\n            // a clone already and it can be safely removed. The question is\n            // how do we know we can remove it. Basically what we can do is\n            // match it against the applyCandidate that you want to apply. If\n            // it doesn't match the we can safely delete it.\n            //\n            // If we didn't do this, then the `replaceSelector` function\n            // would have replaced this with something that didn't exist and\n            // therefore it removed the selector altogether. In this specific\n            // case it would result in `{}` instead of `.something-unrelated {}`\n            if (!extractClasses(rule).some(candidate => candidate === applyCandidate1)) {\n              rule.remove();\n              return;\n            }\n            // Strip the important selector from the parent selector if at the beginning\n            let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null;\n            // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n            // We do *not* want to do this for user CSS that happens to be structured the same\n            let isGenerated = parent.raws.tailwind !== undefined;\n            let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n            rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate1);\n            // And then re-add it if it was removed\n            if (importantSelector && parentSelector !== parent.selector) {\n              rule.selector = `${importantSelector} ${rule.selector}`;\n            }\n            rule.walkDecls(d => {\n              d.important = meta.important || important1;\n            });\n          });\n        }\n        // It could be that the node we were inserted was removed because the class didn't match\n        // If that was the *only* rule in the parent, then we have nothing add so we skip it\n        if (!root1.nodes[0]) {\n          continue;\n        }\n        // Insert it\n        siblings.push([meta.sort, root1.nodes[0]]);\n      }\n    }\n    // Inject the rules, sorted, correctly\n    let nodes = context.offsets.sort(siblings).map(s => s[1]);\n    // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n    parent.after(nodes);\n  }\n  for (let apply1 of applies) {\n    // If there are left-over declarations, just remove the @apply\n    if (apply1.parent.nodes.length > 1) {\n      apply1.remove();\n    } else {\n      // The node is empty, drop the full node\n      apply1.parent.remove();\n    }\n  }\n  // Do it again, in case we have other `@apply` rules\n  processApply(root, context, localCache);\n}\nfunction expandApplyAtRules(context) {\n  return root => {\n    // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n    let localCache = lazyCache(() => buildLocalApplyCache(root, context));\n    processApply(root, context, localCache);\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","expandApplyAtRules","_postcss","_interopRequireDefault","require","_postcssSelectorParser","_generateRules","_escapeClassName","obj","__esModule","default","extractClasses","node","groups","Map","container","root","nodes","clone","walkRules","rule","selectors","walkClasses","classSelector","parentSelector","parent","toString","classes","set","Set","add","processSync","selector","normalizedGroups","Array","from","values","flat","assign","selectorExtractor","extractSelectors","ruleSelectors","astSync","extractBaseCandidates","candidates","separator","baseClasses","candidate","split","pop","prefix","context","tailwindConfig","pathToRoot","shallowClone","overrides","arguments","length","undefined","children","tmp","nestedClone","type","buildLocalApplyCache","cache","_node_raws_tailwind","raws","tailwind","layer","sort","offsets","create","className","list","push","important","buildApplyCache","applyCandidates","notClassCache","has","applyClassCache","classCache","map","_ref","meta","matches","resolveMatches","lazyCache","buildCacheFn","name","combineCaches","caches","flatMap","some","extractApplyCandidates","params","slice","processApply","localCache","applies","walkAtRules","util","replaceSelector","utilitySelectors","selectorList","utilitySelectorsList","candidateList","candidateClass","each","sel","replaced","utilitySelector","hasReplaced","replaceWith","sel1","last","group","isArray","a","b","startsWith","concat","perParentApplies","apply","source","applyCandidates1","screenType","error","c","join","applyCandidate","includes","rules","candidates1","atApplySource","siblings","applyCandidate1","important1","rules1","potentialApplyCandidates","parentClasses","nodeClasses","filter","classList","intersects","root1","walk","canRewriteSelector","remove","importantSelector","isGenerated","indexOf","walkDecls","d","s","after","apply1"],"sources":["/Users/grzegorzlis/Visual_Projects/ztm_web_dev/folder17/robofriends/node_modules/tailwindcss/lib/lib/expandApplyAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: ()=>expandApplyAtRules\n});\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(require(\"postcss\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _generateRules = require(\"./generateRules\");\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(require(\"../util/escapeClassName\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */ function extractClasses(node) {\n    /** @type {Map<string, Set<string>>} */ let groups = new Map();\n    let container = _postcss.default.root({\n        nodes: [\n            node.clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        (0, _postcssSelectorParser.default)((selectors)=>{\n            selectors.walkClasses((classSelector)=>{\n                let parentSelector = classSelector.parent.toString();\n                let classes = groups.get(parentSelector);\n                if (!classes) {\n                    groups.set(parentSelector, classes = new Set());\n                }\n                classes.add(classSelector.value);\n            });\n        }).processSync(rule.selector);\n    });\n    let normalizedGroups = Array.from(groups.values(), (classes)=>Array.from(classes));\n    let classes = normalizedGroups.flat();\n    return Object.assign(classes, {\n        groups: normalizedGroups\n    });\n}\nlet selectorExtractor = (0, _postcssSelectorParser.default)();\n/**\n * @param {string} ruleSelectors\n */ function extractSelectors(ruleSelectors) {\n    return selectorExtractor.astSync(ruleSelectors);\n}\nfunction extractBaseCandidates(candidates, separator) {\n    let baseClasses = new Set();\n    for (let candidate of candidates){\n        baseClasses.add(candidate.split(separator).pop());\n    }\n    return Array.from(baseClasses);\n}\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction* pathToRoot(node) {\n    yield node;\n    while(node.parent){\n        yield node.parent;\n        node = node.parent;\n    }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */ function shallowClone(node, overrides = {}) {\n    let children = node.nodes;\n    node.nodes = [];\n    let tmp = node.clone(overrides);\n    node.nodes = children;\n    return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */ function nestedClone(node) {\n    for (let parent of pathToRoot(node)){\n        if (node === parent) {\n            continue;\n        }\n        if (parent.type === \"root\") {\n            break;\n        }\n        node = shallowClone(parent, {\n            nodes: [\n                node\n            ]\n        });\n    }\n    return node;\n}\n/**\n * @param {import('postcss').Root} root\n */ function buildLocalApplyCache(root, context) {\n    /** @type {ApplyCache} */ let cache = new Map();\n    root.walkRules((rule)=>{\n        // Ignore rules generated by Tailwind\n        for (let node of pathToRoot(rule)){\n            var _node_raws_tailwind;\n            if (((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.layer) !== undefined) {\n                return;\n            }\n        }\n        // Clone what's required to represent this singular rule in the tree\n        let container = nestedClone(rule);\n        let sort = context.offsets.create(\"user\");\n        for (let className of extractClasses(rule)){\n            let list = cache.get(className) || [];\n            cache.set(className, list);\n            list.push([\n                {\n                    layer: \"user\",\n                    sort,\n                    important: false\n                },\n                container\n            ]);\n        }\n    });\n    return cache;\n}\n/**\n * @returns {ApplyCache}\n */ function buildApplyCache(applyCandidates, context) {\n    for (let candidate of applyCandidates){\n        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.classCache.has(candidate)) {\n            context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule])=>[\n                    meta,\n                    rule.clone()\n                ]));\n            continue;\n        }\n        let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.applyClassCache.set(candidate, matches);\n    }\n    return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */ function lazyCache(buildCacheFn) {\n    let cache = null;\n    return {\n        get: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.get(name);\n        },\n        has: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.has(name);\n        }\n    };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */ function combineCaches(caches) {\n    return {\n        get: (name)=>caches.flatMap((cache)=>cache.get(name) || []),\n        has: (name)=>caches.some((cache)=>cache.has(name))\n    };\n}\nfunction extractApplyCandidates(params) {\n    let candidates = params.split(/[\\s\\t\\n]+/g);\n    if (candidates[candidates.length - 1] === \"!important\") {\n        return [\n            candidates.slice(0, -1),\n            true\n        ];\n    }\n    return [\n        candidates,\n        false\n    ];\n}\nfunction processApply(root, context, localCache) {\n    let applyCandidates = new Set();\n    // Collect all @apply rules and candidates\n    let applies = [];\n    root.walkAtRules(\"apply\", (rule)=>{\n        let [candidates] = extractApplyCandidates(rule.params);\n        for (let util of candidates){\n            applyCandidates.add(util);\n        }\n        applies.push(rule);\n    });\n    // Start the @apply process if we have rules with @apply in them\n    if (applies.length === 0) {\n        return;\n    }\n    // Fill up some caches!\n    let applyClassCache = combineCaches([\n        localCache,\n        buildApplyCache(applyCandidates, context)\n    ]);\n    /**\n   * When we have an apply like this:\n   *\n   * .abc {\n   *    @apply hover:font-bold;\n   * }\n   *\n   * What we essentially will do is resolve to this:\n   *\n   * .abc {\n   *    @apply .hover\\:font-bold:hover {\n   *      font-weight: 500;\n   *    }\n   * }\n   *\n   * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n   * What happens in this function is that we prepend a `.` and escape the candidate.\n   * This will result in `.hover\\:font-bold`\n   * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n   *\n   * @param {string} selector\n   * @param {string} utilitySelectors\n   * @param {string} candidate\n   */ function replaceSelector(selector, utilitySelectors, candidate) {\n        let selectorList = extractSelectors(selector);\n        let utilitySelectorsList = extractSelectors(utilitySelectors);\n        let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);\n        let candidateClass = candidateList.nodes[0].nodes[0];\n        selectorList.each((sel)=>{\n            /** @type {Set<import('postcss-selector-parser').Selector>} */ let replaced = new Set();\n            utilitySelectorsList.each((utilitySelector)=>{\n                let hasReplaced = false;\n                utilitySelector = utilitySelector.clone();\n                utilitySelector.walkClasses((node)=>{\n                    if (node.value !== candidateClass.value) {\n                        return;\n                    }\n                    // Don't replace multiple instances of the same class\n                    // This is theoretically correct but only partially\n                    // We'd need to generate every possible permutation of the replacement\n                    // For example with `.foo + .foo { â€¦ }` and `section { @apply foo; }`\n                    // We'd need to generate all of these:\n                    // - `.foo + .foo`\n                    // - `.foo + section`\n                    // - `section + .foo`\n                    // - `section + section`\n                    if (hasReplaced) {\n                        return;\n                    }\n                    // Since you can only `@apply` class names this is sufficient\n                    // We want to replace the matched class name with the selector the user is using\n                    // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`\n                    node.replaceWith(...sel.nodes.map((node)=>node.clone()));\n                    // Record that we did something and we want to use this new selector\n                    replaced.add(utilitySelector);\n                    hasReplaced = true;\n                });\n            });\n            // Sort tag names before class names (but only sort each group (separated by a combinator)\n            // separately and not in total)\n            // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`\n            for (let sel1 of replaced){\n                let groups = [\n                    []\n                ];\n                for (let node of sel1.nodes){\n                    if (node.type === \"combinator\") {\n                        groups.push(node);\n                        groups.push([]);\n                    } else {\n                        let last = groups[groups.length - 1];\n                        last.push(node);\n                    }\n                }\n                sel1.nodes = [];\n                for (let group of groups){\n                    if (Array.isArray(group)) {\n                        group.sort((a, b)=>{\n                            if (a.type === \"tag\" && b.type === \"class\") {\n                                return -1;\n                            } else if (a.type === \"class\" && b.type === \"tag\") {\n                                return 1;\n                            } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n                                return -1;\n                            } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n                                return 1;\n                            }\n                            return 0;\n                        });\n                    }\n                    sel1.nodes = sel1.nodes.concat(group);\n                }\n            }\n            sel.replaceWith(...replaced);\n        });\n        return selectorList.toString();\n    }\n    let perParentApplies = new Map();\n    // Collect all apply candidates and their rules\n    for (let apply of applies){\n        let [candidates] = perParentApplies.get(apply.parent) || [\n            [],\n            apply.source\n        ];\n        perParentApplies.set(apply.parent, [\n            candidates,\n            apply.source\n        ]);\n        let [applyCandidates1, important] = extractApplyCandidates(apply.params);\n        if (apply.parent.type === \"atrule\") {\n            if (apply.parent.name === \"screen\") {\n                let screenType = apply.parent.params;\n                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates1.map((c)=>`${screenType}:${c}`).join(\" \")} instead.`);\n            }\n            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n        }\n        for (let applyCandidate of applyCandidates1){\n            if ([\n                prefix(context, \"group\"),\n                prefix(context, \"peer\")\n            ].includes(applyCandidate)) {\n                // TODO: Link to specific documentation page with error code.\n                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n            }\n            if (!applyClassCache.has(applyCandidate)) {\n                throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n            }\n            let rules = applyClassCache.get(applyCandidate);\n            candidates.push([\n                applyCandidate,\n                important,\n                rules\n            ]);\n        }\n    }\n    for (let [parent, [candidates1, atApplySource]] of perParentApplies){\n        let siblings = [];\n        for (let [applyCandidate1, important1, rules1] of candidates1){\n            let potentialApplyCandidates = [\n                applyCandidate1,\n                ...extractBaseCandidates([\n                    applyCandidate1\n                ], context.tailwindConfig.separator)\n            ];\n            for (let [meta, node] of rules1){\n                let parentClasses = extractClasses(parent);\n                let nodeClasses = extractClasses(node);\n                // When we encounter a rule like `.dark .a, .b { â€¦ }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n                // So we've split them into groups\n                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();\n                // Add base utility classes from the @apply node to the list of\n                // classes to check whether it intersects and therefore results in a\n                // circular dependency or not.\n                //\n                // E.g.:\n                // .foo {\n                //   @apply hover:a; // This applies \"a\" but with a modifier\n                // }\n                //\n                // We only have to do that with base classes of the `node`, not of the `parent`\n                // E.g.:\n                // .hover\\:foo {\n                //   @apply bar;\n                // }\n                // .bar {\n                //   @apply foo;\n                // }\n                //\n                // This should not result in a circular dependency because we are\n                // just applying `.foo` and the rule above is `.hover\\:foo` which is\n                // unrelated. However, if we were to apply `hover:foo` then we _did_\n                // have to include this one.\n                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));\n                if (intersects) {\n                    throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate1}\\` utility here because it creates a circular dependency.`);\n                }\n                let root1 = _postcss.default.root({\n                    nodes: [\n                        node.clone()\n                    ]\n                });\n                // Make sure every node in the entire tree points back at the @apply rule that generated it\n                root1.walk((node)=>{\n                    node.source = atApplySource;\n                });\n                let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n                if (canRewriteSelector) {\n                    root1.walkRules((rule)=>{\n                        // Let's imagine you have the following structure:\n                        //\n                        // .foo {\n                        //   @apply bar;\n                        // }\n                        //\n                        // @supports (a: b) {\n                        //   .bar {\n                        //     color: blue\n                        //   }\n                        //\n                        //   .something-unrelated {}\n                        // }\n                        //\n                        // In this case we want to apply `.bar` but it happens to be in\n                        // an atrule node. We clone that node instead of the nested one\n                        // because we still want that @supports rule to be there once we\n                        // applied everything.\n                        //\n                        // However it happens to be that the `.something-unrelated` is\n                        // also in that same shared @supports atrule. This is not good,\n                        // and this should not be there. The good part is that this is\n                        // a clone already and it can be safely removed. The question is\n                        // how do we know we can remove it. Basically what we can do is\n                        // match it against the applyCandidate that you want to apply. If\n                        // it doesn't match the we can safely delete it.\n                        //\n                        // If we didn't do this, then the `replaceSelector` function\n                        // would have replaced this with something that didn't exist and\n                        // therefore it removed the selector altogether. In this specific\n                        // case it would result in `{}` instead of `.something-unrelated {}`\n                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate1)) {\n                            rule.remove();\n                            return;\n                        }\n                        // Strip the important selector from the parent selector if at the beginning\n                        let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null;\n                        // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n                        // We do *not* want to do this for user CSS that happens to be structured the same\n                        let isGenerated = parent.raws.tailwind !== undefined;\n                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate1);\n                        // And then re-add it if it was removed\n                        if (importantSelector && parentSelector !== parent.selector) {\n                            rule.selector = `${importantSelector} ${rule.selector}`;\n                        }\n                        rule.walkDecls((d)=>{\n                            d.important = meta.important || important1;\n                        });\n                    });\n                }\n                // It could be that the node we were inserted was removed because the class didn't match\n                // If that was the *only* rule in the parent, then we have nothing add so we skip it\n                if (!root1.nodes[0]) {\n                    continue;\n                }\n                // Insert it\n                siblings.push([\n                    meta.sort,\n                    root1.nodes[0]\n                ]);\n            }\n        }\n        // Inject the rules, sorted, correctly\n        let nodes = context.offsets.sort(siblings).map((s)=>s[1]);\n        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n        parent.after(nodes);\n    }\n    for (let apply1 of applies){\n        // If there are left-over declarations, just remove the @apply\n        if (apply1.parent.nodes.length > 1) {\n            apply1.remove();\n        } else {\n            // The node is empty, drop the full node\n            apply1.parent.remove();\n        }\n    }\n    // Do it again, in case we have other `@apply` rules\n    processApply(root, context, localCache);\n}\nfunction expandApplyAtRules(context) {\n    return (root)=>{\n        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));\n        processApply(root, context, localCache);\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}