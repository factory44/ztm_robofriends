{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: () => expandTailwindAtRules\n});\nconst _fs = /*#__PURE__*/_interopRequireDefault(require(\"fs\"));\nconst _quickLru = /*#__PURE__*/_interopRequireDefault(require(\"quick-lru\"));\nconst _sharedState = /*#__PURE__*/_interopRequireWildcard(require(\"./sharedState\"));\nconst _generateRules = require(\"./generateRules\");\nconst _log = /*#__PURE__*/_interopRequireDefault(require(\"../util/log\"));\nconst _cloneNodes = /*#__PURE__*/_interopRequireDefault(require(\"../util/cloneNodes\"));\nconst _defaultExtractor = require(\"./defaultExtractor\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nlet env = _sharedState.env;\nconst builtInExtractors = {\n  DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n  DEFAULT: content => content,\n  svelte: content => content.replace(/(?:^|\\s)class:/g, \" \")\n};\nfunction getExtractor(context, fileExtension) {\n  let extractors = context.tailwindConfig.content.extract;\n  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\nfunction getTransformer(tailwindConfig, fileExtension) {\n  let transformers = tailwindConfig.content.transform;\n  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\nlet extractorCache = new WeakMap();\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n  if (!extractorCache.has(extractor)) {\n    extractorCache.set(extractor, new _quickLru.default({\n      maxSize: 25000\n    }));\n  }\n  for (let line of content.split(\"\\n\")) {\n    line = line.trim();\n    if (seen.has(line)) {\n      continue;\n    }\n    seen.add(line);\n    if (extractorCache.get(extractor).has(line)) {\n      for (let match of extractorCache.get(extractor).get(line)) {\n        candidates.add(match);\n      }\n    } else {\n      let extractorMatches = extractor(line).filter(s => s !== \"!*\");\n      let lineMatchesSet = new Set(extractorMatches);\n      for (let match1 of lineMatchesSet) {\n        candidates.add(match1);\n      }\n      extractorCache.get(extractor).set(line, lineMatchesSet);\n    }\n  }\n}\n/**\n *\n * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules\n * @param {*} context\n */\nfunction buildStylesheet(rules, context) {\n  let sortedRules = context.offsets.sort(rules);\n  let returnValue = {\n    base: new Set(),\n    defaults: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    variants: new Set()\n  };\n  for (let [sort, rule] of sortedRules) {\n    returnValue[sort.layer].add(rule);\n  }\n  return returnValue;\n}\nfunction expandTailwindAtRules(context) {\n  return root => {\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      variants: null\n    };\n    root.walkAtRules(rule => {\n      // Make sure this file contains Tailwind directives. If not, we can save\n      // a lot of work and bail early. Also we don't have to register our touch\n      // file as a dependency since the output of this CSS does not depend on\n      // the source of any templates. Think Vue <style> blocks for example.\n      if (rule.name === \"tailwind\") {\n        if (Object.keys(layerNodes).includes(rule.params)) {\n          layerNodes[rule.params] = rule;\n        }\n      }\n    });\n    if (Object.values(layerNodes).every(n => n === null)) {\n      return root;\n    }\n    var _context_candidates;\n    // ---\n    // Find potential rules in changed files\n    let candidates = new Set([...((_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : []), _sharedState.NOT_ON_DEMAND]);\n    let seen = new Set();\n    env.DEBUG && console.time(\"Reading changed files\");\n    if (env.OXIDE) {\n      // TODO: Pass through or implement `extractor`\n      for (let candidate of require(\"@tailwindcss/oxide\").parseCandidateStringsFromFiles(context.changedContent)) {\n        candidates.add(candidate);\n      }\n      // for (let { file, content, extension } of context.changedContent) {\n      //   let transformer = getTransformer(context.tailwindConfig, extension)\n      //   let extractor = getExtractor(context, extension)\n      //   getClassCandidatesOxide(file, transformer(content), extractor, candidates, seen)\n      // }\n    } else {\n      for (let {\n        file,\n        content,\n        extension\n      } of context.changedContent) {\n        let transformer = getTransformer(context.tailwindConfig, extension);\n        let extractor = getExtractor(context, extension);\n        content = file ? _fs.default.readFileSync(file, \"utf8\") : content;\n        getClassCandidates(transformer(content), extractor, candidates, seen);\n      }\n    }\n    env.DEBUG && console.timeEnd(\"Reading changed files\");\n    // ---\n    // Generate the actual CSS\n    let classCacheCount = context.classCache.size;\n    env.DEBUG && console.time(\"Generate rules\");\n    env.DEBUG && console.time(\"Sorting candidates\");\n    let sortedCandidates = env.OXIDE ? candidates : new Set([...candidates].sort((a, z) => {\n      if (a === z) return 0;\n      if (a < z) return -1;\n      return 1;\n    }));\n    env.DEBUG && console.timeEnd(\"Sorting candidates\");\n    (0, _generateRules.generateRules)(sortedCandidates, context);\n    env.DEBUG && console.timeEnd(\"Generate rules\");\n    // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n    env.DEBUG && console.time(\"Build stylesheet\");\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);\n    }\n    env.DEBUG && console.timeEnd(\"Build stylesheet\");\n    let {\n      defaults: defaultNodes,\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      variants: screenNodes\n    } = context.stylesheetCache;\n    // ---\n    // Replace any Tailwind directives with generated CSS\n    if (layerNodes.base) {\n      layerNodes.base.before((0, _cloneNodes.default)([...baseNodes, ...defaultNodes], layerNodes.base.source, {\n        layer: \"base\"\n      }));\n      layerNodes.base.remove();\n    }\n    if (layerNodes.components) {\n      layerNodes.components.before((0, _cloneNodes.default)([...componentNodes], layerNodes.components.source, {\n        layer: \"components\"\n      }));\n      layerNodes.components.remove();\n    }\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before((0, _cloneNodes.default)([...utilityNodes], layerNodes.utilities.source, {\n        layer: \"utilities\"\n      }));\n      layerNodes.utilities.remove();\n    }\n    // We do post-filtering to not alter the emitted order of the variants\n    const variantNodes = Array.from(screenNodes).filter(node => {\n      var _node_raws_tailwind;\n      const parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;\n      if (parentLayer === \"components\") {\n        return layerNodes.components !== null;\n      }\n      if (parentLayer === \"utilities\") {\n        return layerNodes.utilities !== null;\n      }\n      return true;\n    });\n    if (layerNodes.variants) {\n      layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n        layer: \"variants\"\n      }));\n      layerNodes.variants.remove();\n    } else if (variantNodes.length > 0) {\n      root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n        layer: \"variants\"\n      }));\n    }\n    // If we've got a utility layer and no utilities are generated there's likely something wrong\n    const hasUtilityVariants = variantNodes.some(node => {\n      var _node_raws_tailwind;\n      return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === \"utilities\";\n    });\n    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n      _log.default.warn(\"content-problems\", [\"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\", \"https://tailwindcss.com/docs/content-configuration\"]);\n    }\n    // ---\n    if (env.DEBUG) {\n      console.log(\"Potential classes: \", candidates.size);\n      console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n    }\n    // Clear the cache for the changed files\n    context.changedContent = [];\n    // Cleanup any leftover @layer atrules\n    root.walkAtRules(\"layer\", rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        rule.remove();\n      }\n    });\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","expandTailwindAtRules","_fs","_interopRequireDefault","require","_quickLru","_sharedState","_interopRequireWildcard","_generateRules","_log","_cloneNodes","_defaultExtractor","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","env","builtInExtractors","DEFAULT","defaultExtractor","builtInTransformers","content","svelte","replace","getExtractor","context","fileExtension","extractors","tailwindConfig","extract","getTransformer","transformers","transform","extractorCache","getClassCandidates","extractor","candidates","seen","maxSize","line","split","trim","add","match","extractorMatches","filter","s","lineMatchesSet","Set","match1","buildStylesheet","rules","sortedRules","offsets","sort","returnValue","base","defaults","components","utilities","variants","rule","layer","root","layerNodes","walkAtRules","name","keys","includes","params","values","every","n","_context_candidates","NOT_ON_DEMAND","DEBUG","console","time","OXIDE","candidate","parseCandidateStringsFromFiles","changedContent","file","extension","transformer","readFileSync","timeEnd","classCacheCount","classCache","size","sortedCandidates","a","z","generateRules","stylesheetCache","ruleCache","defaultNodes","baseNodes","componentNodes","utilityNodes","screenNodes","before","source","remove","variantNodes","Array","from","node","_node_raws_tailwind","parentLayer","raws","tailwind","length","append","hasUtilityVariants","some","warn","log","contextSourcesMap"],"sources":["/Users/grzegorzlis/Visual_Projects/ztm_web_dev/folder17/robofriends/node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: ()=>expandTailwindAtRules\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(require(\"fs\"));\nconst _quickLru = /*#__PURE__*/ _interopRequireDefault(require(\"quick-lru\"));\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(require(\"./sharedState\"));\nconst _generateRules = require(\"./generateRules\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(require(\"../util/log\"));\nconst _cloneNodes = /*#__PURE__*/ _interopRequireDefault(require(\"../util/cloneNodes\"));\nconst _defaultExtractor = require(\"./defaultExtractor\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet env = _sharedState.env;\nconst builtInExtractors = {\n    DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n    DEFAULT: (content)=>content,\n    svelte: (content)=>content.replace(/(?:^|\\s)class:/g, \" \")\n};\nfunction getExtractor(context, fileExtension) {\n    let extractors = context.tailwindConfig.content.extract;\n    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\nfunction getTransformer(tailwindConfig, fileExtension) {\n    let transformers = tailwindConfig.content.transform;\n    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\nlet extractorCache = new WeakMap();\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n    if (!extractorCache.has(extractor)) {\n        extractorCache.set(extractor, new _quickLru.default({\n            maxSize: 25000\n        }));\n    }\n    for (let line of content.split(\"\\n\")){\n        line = line.trim();\n        if (seen.has(line)) {\n            continue;\n        }\n        seen.add(line);\n        if (extractorCache.get(extractor).has(line)) {\n            for (let match of extractorCache.get(extractor).get(line)){\n                candidates.add(match);\n            }\n        } else {\n            let extractorMatches = extractor(line).filter((s)=>s !== \"!*\");\n            let lineMatchesSet = new Set(extractorMatches);\n            for (let match1 of lineMatchesSet){\n                candidates.add(match1);\n            }\n            extractorCache.get(extractor).set(line, lineMatchesSet);\n        }\n    }\n}\n/**\n *\n * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules\n * @param {*} context\n */ function buildStylesheet(rules, context) {\n    let sortedRules = context.offsets.sort(rules);\n    let returnValue = {\n        base: new Set(),\n        defaults: new Set(),\n        components: new Set(),\n        utilities: new Set(),\n        variants: new Set()\n    };\n    for (let [sort, rule] of sortedRules){\n        returnValue[sort.layer].add(rule);\n    }\n    return returnValue;\n}\nfunction expandTailwindAtRules(context) {\n    return (root)=>{\n        let layerNodes = {\n            base: null,\n            components: null,\n            utilities: null,\n            variants: null\n        };\n        root.walkAtRules((rule)=>{\n            // Make sure this file contains Tailwind directives. If not, we can save\n            // a lot of work and bail early. Also we don't have to register our touch\n            // file as a dependency since the output of this CSS does not depend on\n            // the source of any templates. Think Vue <style> blocks for example.\n            if (rule.name === \"tailwind\") {\n                if (Object.keys(layerNodes).includes(rule.params)) {\n                    layerNodes[rule.params] = rule;\n                }\n            }\n        });\n        if (Object.values(layerNodes).every((n)=>n === null)) {\n            return root;\n        }\n        var _context_candidates;\n        // ---\n        // Find potential rules in changed files\n        let candidates = new Set([\n            ...(_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : [],\n            _sharedState.NOT_ON_DEMAND\n        ]);\n        let seen = new Set();\n        env.DEBUG && console.time(\"Reading changed files\");\n        if (env.OXIDE) {\n            // TODO: Pass through or implement `extractor`\n            for (let candidate of require(\"@tailwindcss/oxide\").parseCandidateStringsFromFiles(context.changedContent)){\n                candidates.add(candidate);\n            }\n        // for (let { file, content, extension } of context.changedContent) {\n        //   let transformer = getTransformer(context.tailwindConfig, extension)\n        //   let extractor = getExtractor(context, extension)\n        //   getClassCandidatesOxide(file, transformer(content), extractor, candidates, seen)\n        // }\n        } else {\n            for (let { file , content , extension  } of context.changedContent){\n                let transformer = getTransformer(context.tailwindConfig, extension);\n                let extractor = getExtractor(context, extension);\n                content = file ? _fs.default.readFileSync(file, \"utf8\") : content;\n                getClassCandidates(transformer(content), extractor, candidates, seen);\n            }\n        }\n        env.DEBUG && console.timeEnd(\"Reading changed files\");\n        // ---\n        // Generate the actual CSS\n        let classCacheCount = context.classCache.size;\n        env.DEBUG && console.time(\"Generate rules\");\n        env.DEBUG && console.time(\"Sorting candidates\");\n        let sortedCandidates = env.OXIDE ? candidates : new Set([\n            ...candidates\n        ].sort((a, z)=>{\n            if (a === z) return 0;\n            if (a < z) return -1;\n            return 1;\n        }));\n        env.DEBUG && console.timeEnd(\"Sorting candidates\");\n        (0, _generateRules.generateRules)(sortedCandidates, context);\n        env.DEBUG && console.timeEnd(\"Generate rules\");\n        // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n        env.DEBUG && console.time(\"Build stylesheet\");\n        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n            context.stylesheetCache = buildStylesheet([\n                ...context.ruleCache\n            ], context);\n        }\n        env.DEBUG && console.timeEnd(\"Build stylesheet\");\n        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes  } = context.stylesheetCache;\n        // ---\n        // Replace any Tailwind directives with generated CSS\n        if (layerNodes.base) {\n            layerNodes.base.before((0, _cloneNodes.default)([\n                ...baseNodes,\n                ...defaultNodes\n            ], layerNodes.base.source, {\n                layer: \"base\"\n            }));\n            layerNodes.base.remove();\n        }\n        if (layerNodes.components) {\n            layerNodes.components.before((0, _cloneNodes.default)([\n                ...componentNodes\n            ], layerNodes.components.source, {\n                layer: \"components\"\n            }));\n            layerNodes.components.remove();\n        }\n        if (layerNodes.utilities) {\n            layerNodes.utilities.before((0, _cloneNodes.default)([\n                ...utilityNodes\n            ], layerNodes.utilities.source, {\n                layer: \"utilities\"\n            }));\n            layerNodes.utilities.remove();\n        }\n        // We do post-filtering to not alter the emitted order of the variants\n        const variantNodes = Array.from(screenNodes).filter((node)=>{\n            var _node_raws_tailwind;\n            const parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;\n            if (parentLayer === \"components\") {\n                return layerNodes.components !== null;\n            }\n            if (parentLayer === \"utilities\") {\n                return layerNodes.utilities !== null;\n            }\n            return true;\n        });\n        if (layerNodes.variants) {\n            layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n                layer: \"variants\"\n            }));\n            layerNodes.variants.remove();\n        } else if (variantNodes.length > 0) {\n            root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n                layer: \"variants\"\n            }));\n        }\n        // If we've got a utility layer and no utilities are generated there's likely something wrong\n        const hasUtilityVariants = variantNodes.some((node)=>{\n            var _node_raws_tailwind;\n            return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === \"utilities\";\n        });\n        if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n            _log.default.warn(\"content-problems\", [\n                \"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\",\n                \"https://tailwindcss.com/docs/content-configuration\"\n            ]);\n        }\n        // ---\n        if (env.DEBUG) {\n            console.log(\"Potential classes: \", candidates.size);\n            console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n        }\n        // Clear the cache for the changed files\n        context.changedContent = [];\n        // Cleanup any leftover @layer atrules\n        root.walkAtRules(\"layer\", (rule)=>{\n            if (Object.keys(layerNodes).includes(rule.params)) {\n                rule.remove();\n            }\n        });\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}