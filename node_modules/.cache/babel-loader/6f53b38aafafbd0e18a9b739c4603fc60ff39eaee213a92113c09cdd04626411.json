{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  formatVariantSelector: () => formatVariantSelector,\n  eliminateIrrelevantSelectors: () => eliminateIrrelevantSelectors,\n  finalizeSelector: () => finalizeSelector,\n  handleMergePseudo: () => handleMergePseudo\n});\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/_interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/_interopRequireDefault(require(\"../util/prefixSelector\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, isArbitraryVariant: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */\nlet MERGE = \":merge\";\nfunction formatVariantSelector(formats, _ref) {\n  let {\n    context,\n    candidate\n  } = _ref;\n  var _context_tailwindConfig_prefix;\n  let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : \"\";\n  // Parse the format selector into an AST\n  let parsedFormats = formats.map(format => {\n    let ast = (0, _postcssSelectorParser.default)().astSync(format.format);\n    return {\n      ...format,\n      ast: format.isArbitraryVariant ? ast : (0, _prefixSelector.default)(prefix, ast)\n    };\n  });\n  // We start with the candidate selector\n  let formatAst = _postcssSelectorParser.default.root({\n    nodes: [_postcssSelectorParser.default.selector({\n      nodes: [_postcssSelectorParser.default.className({\n        value: (0, _escapeClassName.default)(candidate)\n      })]\n    })]\n  });\n  // And iteratively merge each format selector into the candidate selector\n  for (let {\n    ast\n  } of parsedFormats) {\n    [formatAst, ast] = handleMergePseudo(formatAst, ast);\n    // 2. Merge the format selector into the current selector AST\n    ast.walkNesting(nesting => nesting.replaceWith(...formatAst.nodes[0].nodes));\n    // 3. Keep going!\n    formatAst = ast;\n  }\n  return formatAst;\n}\n/**\n * Given any node in a selector this gets the \"simple\" selector it's a part of\n * A simple selector is just a list of nodes without any combinators\n * Technically :is(), :not(), :has(), etc… can have combinators but those are nested\n * inside the relevant node and won't be picked up so they're fine to ignore\n *\n * @param {Node} node\n * @returns {Node[]}\n **/\nfunction simpleSelectorForNode(node) {\n  /** @type {Node[]} */let nodes = [];\n  // Walk backwards until we hit a combinator node (or the start)\n  while (node.prev() && node.prev().type !== \"combinator\") {\n    node = node.prev();\n  }\n  // Now record all non-combinator nodes until we hit one (or the end)\n  while (node && node.type !== \"combinator\") {\n    nodes.push(node);\n    node = node.next();\n  }\n  return nodes;\n}\n/**\n * Resorts the nodes in a selector to ensure they're in the correct order\n * Tags go before classes, and pseudo classes go after classes\n *\n * @param {Selector} sel\n * @returns {Selector}\n **/\nfunction resortSelector(sel) {\n  sel.sort((a, b) => {\n    if (a.type === \"tag\" && b.type === \"class\") {\n      return -1;\n    } else if (a.type === \"class\" && b.type === \"tag\") {\n      return 1;\n    } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n      return -1;\n    } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n      return 1;\n    }\n    return sel.index(a) - sel.index(b);\n  });\n  return sel;\n}\nfunction eliminateIrrelevantSelectors(sel, base) {\n  let hasClassesMatchingCandidate = false;\n  sel.walk(child => {\n    if (child.type === \"class\" && child.value === base) {\n      hasClassesMatchingCandidate = true;\n      return false // Stop walking\n      ;\n    }\n  });\n\n  if (!hasClassesMatchingCandidate) {\n    sel.remove();\n  }\n  // We do NOT recursively eliminate sub selectors that don't have the base class\n  // as this is NOT a safe operation. For example, if we have:\n  // `.space-x-2 > :not([hidden]) ~ :not([hidden])`\n  // We cannot remove the [hidden] from the :not() because it would change the\n  // meaning of the selector.\n  // TODO: Can we do this for :matches, :is, and :where?\n}\n\nfunction finalizeSelector(current, formats, _ref2) {\n  let {\n    context,\n    candidate,\n    base\n  } = _ref2;\n  var _context_tailwindConfig;\n  var _context_tailwindConfig_separator;\n  let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : \":\";\n  // Split by the separator, but ignore the separator inside square brackets:\n  //\n  // E.g.: dark:lg:hover:[paint-order:markers]\n  //           ┬  ┬     ┬            ┬\n  //           │  │     │            ╰── We will not split here\n  //           ╰──┴─────┴─────────────── We will split here\n  //\n  base = base !== null && base !== void 0 ? base : candidate.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`)).pop();\n  // Parse the selector into an AST\n  let selector = (0, _postcssSelectorParser.default)().astSync(current);\n  // Normalize escaped classes, e.g.:\n  //\n  // The idea would be to replace the escaped `base` in the selector with the\n  // `format`. However, in css you can escape the same selector in a few\n  // different ways. This would result in different strings and therefore we\n  // can't replace it properly.\n  //\n  //               base: bg-[rgb(255,0,0)]\n  //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n  //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n  //\n  selector.walkClasses(node => {\n    if (node.raws && node.value.includes(base)) {\n      node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n    }\n  });\n  // Remove extraneous selectors that do not include the base candidate\n  selector.each(sel => eliminateIrrelevantSelectors(sel, base));\n  // If there are no formats that means there were no variants added to the candidate\n  // so we can just return the selector as-is\n  let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {\n    context,\n    candidate\n  }) : formats;\n  if (formatAst === null) {\n    return selector.toString();\n  }\n  let simpleStart = _postcssSelectorParser.default.comment({\n    value: \"/*__simple__*/\"\n  });\n  let simpleEnd = _postcssSelectorParser.default.comment({\n    value: \"/*__simple__*/\"\n  });\n  // We can safely replace the escaped base now, since the `base` section is\n  // now in a normalized escaped value.\n  selector.walkClasses(node => {\n    if (node.value !== base) {\n      return;\n    }\n    let parent = node.parent;\n    let formatNodes = formatAst.nodes[0].nodes;\n    // Perf optimization: if the parent is a single class we can just replace it and be done\n    if (parent.nodes.length === 1) {\n      node.replaceWith(...formatNodes);\n      return;\n    }\n    let simpleSelector = simpleSelectorForNode(node);\n    parent.insertBefore(simpleSelector[0], simpleStart);\n    parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);\n    for (let child of formatNodes) {\n      parent.insertBefore(simpleSelector[0], child.clone());\n    }\n    node.remove();\n    // Re-sort the simple selector to ensure it's in the correct order\n    simpleSelector = simpleSelectorForNode(simpleStart);\n    let firstNode = parent.index(simpleStart);\n    parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssSelectorParser.default.selector({\n      nodes: simpleSelector\n    })).nodes);\n    simpleStart.remove();\n    simpleEnd.remove();\n  });\n  // Remove unnecessary pseudo selectors that we used as placeholders\n  selector.walkPseudos(p => {\n    if (p.value === MERGE) {\n      p.replaceWith(p.nodes);\n    }\n  });\n  // Move pseudo elements to the end of the selector (if necessary)\n  selector.each(sel => {\n    let pseudoElements = collectPseudoElements(sel);\n    if (pseudoElements.length > 0) {\n      sel.nodes.push(pseudoElements.sort(sortSelector));\n    }\n  });\n  return selector.toString();\n}\nfunction handleMergePseudo(selector, format) {\n  /** @type {{pseudo: Pseudo, value: string}[]} */let merges = [];\n  // Find all :merge() pseudo-classes in `selector`\n  selector.walkPseudos(pseudo => {\n    if (pseudo.value === MERGE) {\n      merges.push({\n        pseudo,\n        value: pseudo.nodes[0].toString()\n      });\n    }\n  });\n  // Find all :merge() \"attachments\" in `format` and attach them to the matching selector in `selector`\n  format.walkPseudos(pseudo => {\n    if (pseudo.value !== MERGE) {\n      return;\n    }\n    let value = pseudo.nodes[0].toString();\n    // Does `selector` contain a :merge() pseudo-class with the same value?\n    let existing = merges.find(merge => merge.value === value);\n    // Nope so there's nothing to do\n    if (!existing) {\n      return;\n    }\n    // Everything after `:merge()` up to the next combinator is what is attached to the merged selector\n    let attachments = [];\n    let next = pseudo.next();\n    while (next && next.type !== \"combinator\") {\n      attachments.push(next);\n      next = next.next();\n    }\n    let combinator = next;\n    existing.pseudo.parent.insertAfter(existing.pseudo, _postcssSelectorParser.default.selector({\n      nodes: attachments.map(node => node.clone())\n    }));\n    pseudo.remove();\n    attachments.forEach(node => node.remove());\n    // What about this case:\n    // :merge(.group):focus > &\n    // :merge(.group):hover &\n    if (combinator && combinator.type === \"combinator\") {\n      combinator.remove();\n    }\n  });\n  return [selector, format];\n}\n// Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\nlet pseudoElementsBC = [\":before\", \":after\", \":first-line\", \":first-letter\"];\n// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\nlet pseudoElementExceptions = [\"::file-selector-button\",\n// Webkit scroll bar pseudo elements can be combined with user-action pseudo classes\n\"::-webkit-scrollbar\", \"::-webkit-scrollbar-button\", \"::-webkit-scrollbar-thumb\", \"::-webkit-scrollbar-track\", \"::-webkit-scrollbar-track-piece\", \"::-webkit-scrollbar-corner\", \"::-webkit-resizer\"];\n/**\n * This will make sure to move pseudo's to the correct spot (the end for\n * pseudo elements) because otherwise the selector will never work\n * anyway.\n *\n * E.g.:\n *  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n *  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n *\n * `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n *\n * @param {Selector} selector\n **/\nfunction collectPseudoElements(selector) {\n  /** @type {Node[]} */let nodes = [];\n  for (let node of selector.nodes) {\n    if (isPseudoElement(node)) {\n      nodes.push(node);\n      selector.removeChild(node);\n    }\n    if (node === null || node === void 0 ? void 0 : node.nodes) {\n      nodes.push(...collectPseudoElements(node));\n    }\n  }\n  return nodes;\n}\n// This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\nfunction sortSelector(a, z) {\n  // Both nodes are non-pseudo's so we can safely ignore them and keep\n  // them in the same order.\n  if (a.type !== \"pseudo\" && z.type !== \"pseudo\") {\n    return 0;\n  }\n  // If one of them is a combinator, we need to keep it in the same order\n  // because that means it will start a new \"section\" in the selector.\n  if (a.type === \"combinator\" ^ z.type === \"combinator\") {\n    return 0;\n  }\n  // One of the items is a pseudo and the other one isn't. Let's move\n  // the pseudo to the right.\n  if (a.type === \"pseudo\" ^ z.type === \"pseudo\") {\n    return (a.type === \"pseudo\") - (z.type === \"pseudo\");\n  }\n  // Both are pseudo's, move the pseudo elements (except for\n  // ::file-selector-button) to the right.\n  return isPseudoElement(a) - isPseudoElement(z);\n}\nfunction isPseudoElement(node) {\n  if (node.type !== \"pseudo\") return false;\n  if (pseudoElementExceptions.includes(node.value)) return false;\n  return node.value.startsWith(\"::\") || pseudoElementsBC.includes(node.value);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","formatVariantSelector","eliminateIrrelevantSelectors","finalizeSelector","handleMergePseudo","_postcssSelectorParser","_interopRequireDefault","require","_unesc","_escapeClassName","_prefixSelector","obj","__esModule","default","MERGE","formats","_ref","context","candidate","_context_tailwindConfig_prefix","prefix","tailwindConfig","parsedFormats","map","format","ast","astSync","isArbitraryVariant","formatAst","root","nodes","selector","className","walkNesting","nesting","replaceWith","simpleSelectorForNode","node","prev","type","push","next","resortSelector","sel","sort","a","b","startsWith","index","base","hasClassesMatchingCandidate","walk","child","remove","current","_ref2","_context_tailwindConfig","_context_tailwindConfig_separator","separator","split","RegExp","pop","walkClasses","raws","includes","each","Array","isArray","toString","simpleStart","comment","simpleEnd","parent","formatNodes","length","simpleSelector","insertBefore","insertAfter","clone","firstNode","splice","walkPseudos","p","pseudoElements","collectPseudoElements","sortSelector","merges","pseudo","existing","find","merge","attachments","combinator","forEach","pseudoElementsBC","pseudoElementExceptions","isPseudoElement","removeChild","z"],"sources":["/Users/grzegorzlis/Visual_Projects/ztm_web_dev/folder17/robofriends/node_modules/tailwindcss/lib/util/formatVariantSelector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatVariantSelector: ()=>formatVariantSelector,\n    eliminateIrrelevantSelectors: ()=>eliminateIrrelevantSelectors,\n    finalizeSelector: ()=>finalizeSelector,\n    handleMergePseudo: ()=>handleMergePseudo\n});\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(require(\"../util/prefixSelector\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, isArbitraryVariant: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */ let MERGE = \":merge\";\nfunction formatVariantSelector(formats, { context , candidate  }) {\n    var _context_tailwindConfig_prefix;\n    let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : \"\";\n    // Parse the format selector into an AST\n    let parsedFormats = formats.map((format)=>{\n        let ast = (0, _postcssSelectorParser.default)().astSync(format.format);\n        return {\n            ...format,\n            ast: format.isArbitraryVariant ? ast : (0, _prefixSelector.default)(prefix, ast)\n        };\n    });\n    // We start with the candidate selector\n    let formatAst = _postcssSelectorParser.default.root({\n        nodes: [\n            _postcssSelectorParser.default.selector({\n                nodes: [\n                    _postcssSelectorParser.default.className({\n                        value: (0, _escapeClassName.default)(candidate)\n                    })\n                ]\n            })\n        ]\n    });\n    // And iteratively merge each format selector into the candidate selector\n    for (let { ast  } of parsedFormats){\n        [formatAst, ast] = handleMergePseudo(formatAst, ast);\n        // 2. Merge the format selector into the current selector AST\n        ast.walkNesting((nesting)=>nesting.replaceWith(...formatAst.nodes[0].nodes));\n        // 3. Keep going!\n        formatAst = ast;\n    }\n    return formatAst;\n}\n/**\n * Given any node in a selector this gets the \"simple\" selector it's a part of\n * A simple selector is just a list of nodes without any combinators\n * Technically :is(), :not(), :has(), etc… can have combinators but those are nested\n * inside the relevant node and won't be picked up so they're fine to ignore\n *\n * @param {Node} node\n * @returns {Node[]}\n **/ function simpleSelectorForNode(node) {\n    /** @type {Node[]} */ let nodes = [];\n    // Walk backwards until we hit a combinator node (or the start)\n    while(node.prev() && node.prev().type !== \"combinator\"){\n        node = node.prev();\n    }\n    // Now record all non-combinator nodes until we hit one (or the end)\n    while(node && node.type !== \"combinator\"){\n        nodes.push(node);\n        node = node.next();\n    }\n    return nodes;\n}\n/**\n * Resorts the nodes in a selector to ensure they're in the correct order\n * Tags go before classes, and pseudo classes go after classes\n *\n * @param {Selector} sel\n * @returns {Selector}\n **/ function resortSelector(sel) {\n    sel.sort((a, b)=>{\n        if (a.type === \"tag\" && b.type === \"class\") {\n            return -1;\n        } else if (a.type === \"class\" && b.type === \"tag\") {\n            return 1;\n        } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n            return -1;\n        } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n            return 1;\n        }\n        return sel.index(a) - sel.index(b);\n    });\n    return sel;\n}\nfunction eliminateIrrelevantSelectors(sel, base) {\n    let hasClassesMatchingCandidate = false;\n    sel.walk((child)=>{\n        if (child.type === \"class\" && child.value === base) {\n            hasClassesMatchingCandidate = true;\n            return false // Stop walking\n            ;\n        }\n    });\n    if (!hasClassesMatchingCandidate) {\n        sel.remove();\n    }\n// We do NOT recursively eliminate sub selectors that don't have the base class\n// as this is NOT a safe operation. For example, if we have:\n// `.space-x-2 > :not([hidden]) ~ :not([hidden])`\n// We cannot remove the [hidden] from the :not() because it would change the\n// meaning of the selector.\n// TODO: Can we do this for :matches, :is, and :where?\n}\nfunction finalizeSelector(current, formats, { context , candidate , base  }) {\n    var _context_tailwindConfig;\n    var _context_tailwindConfig_separator;\n    let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : \":\";\n    // Split by the separator, but ignore the separator inside square brackets:\n    //\n    // E.g.: dark:lg:hover:[paint-order:markers]\n    //           ┬  ┬     ┬            ┬\n    //           │  │     │            ╰── We will not split here\n    //           ╰──┴─────┴─────────────── We will split here\n    //\n    base = base !== null && base !== void 0 ? base : candidate.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`)).pop();\n    // Parse the selector into an AST\n    let selector = (0, _postcssSelectorParser.default)().astSync(current);\n    // Normalize escaped classes, e.g.:\n    //\n    // The idea would be to replace the escaped `base` in the selector with the\n    // `format`. However, in css you can escape the same selector in a few\n    // different ways. This would result in different strings and therefore we\n    // can't replace it properly.\n    //\n    //               base: bg-[rgb(255,0,0)]\n    //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n    //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n    //\n    selector.walkClasses((node)=>{\n        if (node.raws && node.value.includes(base)) {\n            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n        }\n    });\n    // Remove extraneous selectors that do not include the base candidate\n    selector.each((sel)=>eliminateIrrelevantSelectors(sel, base));\n    // If there are no formats that means there were no variants added to the candidate\n    // so we can just return the selector as-is\n    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {\n        context,\n        candidate\n    }) : formats;\n    if (formatAst === null) {\n        return selector.toString();\n    }\n    let simpleStart = _postcssSelectorParser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    let simpleEnd = _postcssSelectorParser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    // We can safely replace the escaped base now, since the `base` section is\n    // now in a normalized escaped value.\n    selector.walkClasses((node)=>{\n        if (node.value !== base) {\n            return;\n        }\n        let parent = node.parent;\n        let formatNodes = formatAst.nodes[0].nodes;\n        // Perf optimization: if the parent is a single class we can just replace it and be done\n        if (parent.nodes.length === 1) {\n            node.replaceWith(...formatNodes);\n            return;\n        }\n        let simpleSelector = simpleSelectorForNode(node);\n        parent.insertBefore(simpleSelector[0], simpleStart);\n        parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);\n        for (let child of formatNodes){\n            parent.insertBefore(simpleSelector[0], child.clone());\n        }\n        node.remove();\n        // Re-sort the simple selector to ensure it's in the correct order\n        simpleSelector = simpleSelectorForNode(simpleStart);\n        let firstNode = parent.index(simpleStart);\n        parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssSelectorParser.default.selector({\n            nodes: simpleSelector\n        })).nodes);\n        simpleStart.remove();\n        simpleEnd.remove();\n    });\n    // Remove unnecessary pseudo selectors that we used as placeholders\n    selector.walkPseudos((p)=>{\n        if (p.value === MERGE) {\n            p.replaceWith(p.nodes);\n        }\n    });\n    // Move pseudo elements to the end of the selector (if necessary)\n    selector.each((sel)=>{\n        let pseudoElements = collectPseudoElements(sel);\n        if (pseudoElements.length > 0) {\n            sel.nodes.push(pseudoElements.sort(sortSelector));\n        }\n    });\n    return selector.toString();\n}\nfunction handleMergePseudo(selector, format) {\n    /** @type {{pseudo: Pseudo, value: string}[]} */ let merges = [];\n    // Find all :merge() pseudo-classes in `selector`\n    selector.walkPseudos((pseudo)=>{\n        if (pseudo.value === MERGE) {\n            merges.push({\n                pseudo,\n                value: pseudo.nodes[0].toString()\n            });\n        }\n    });\n    // Find all :merge() \"attachments\" in `format` and attach them to the matching selector in `selector`\n    format.walkPseudos((pseudo)=>{\n        if (pseudo.value !== MERGE) {\n            return;\n        }\n        let value = pseudo.nodes[0].toString();\n        // Does `selector` contain a :merge() pseudo-class with the same value?\n        let existing = merges.find((merge)=>merge.value === value);\n        // Nope so there's nothing to do\n        if (!existing) {\n            return;\n        }\n        // Everything after `:merge()` up to the next combinator is what is attached to the merged selector\n        let attachments = [];\n        let next = pseudo.next();\n        while(next && next.type !== \"combinator\"){\n            attachments.push(next);\n            next = next.next();\n        }\n        let combinator = next;\n        existing.pseudo.parent.insertAfter(existing.pseudo, _postcssSelectorParser.default.selector({\n            nodes: attachments.map((node)=>node.clone())\n        }));\n        pseudo.remove();\n        attachments.forEach((node)=>node.remove());\n        // What about this case:\n        // :merge(.group):focus > &\n        // :merge(.group):hover &\n        if (combinator && combinator.type === \"combinator\") {\n            combinator.remove();\n        }\n    });\n    return [\n        selector,\n        format\n    ];\n}\n// Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\nlet pseudoElementsBC = [\n    \":before\",\n    \":after\",\n    \":first-line\",\n    \":first-letter\"\n];\n// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\nlet pseudoElementExceptions = [\n    \"::file-selector-button\",\n    // Webkit scroll bar pseudo elements can be combined with user-action pseudo classes\n    \"::-webkit-scrollbar\",\n    \"::-webkit-scrollbar-button\",\n    \"::-webkit-scrollbar-thumb\",\n    \"::-webkit-scrollbar-track\",\n    \"::-webkit-scrollbar-track-piece\",\n    \"::-webkit-scrollbar-corner\",\n    \"::-webkit-resizer\"\n];\n/**\n * This will make sure to move pseudo's to the correct spot (the end for\n * pseudo elements) because otherwise the selector will never work\n * anyway.\n *\n * E.g.:\n *  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n *  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n *\n * `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n *\n * @param {Selector} selector\n **/ function collectPseudoElements(selector) {\n    /** @type {Node[]} */ let nodes = [];\n    for (let node of selector.nodes){\n        if (isPseudoElement(node)) {\n            nodes.push(node);\n            selector.removeChild(node);\n        }\n        if (node === null || node === void 0 ? void 0 : node.nodes) {\n            nodes.push(...collectPseudoElements(node));\n        }\n    }\n    return nodes;\n}\n// This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\nfunction sortSelector(a, z) {\n    // Both nodes are non-pseudo's so we can safely ignore them and keep\n    // them in the same order.\n    if (a.type !== \"pseudo\" && z.type !== \"pseudo\") {\n        return 0;\n    }\n    // If one of them is a combinator, we need to keep it in the same order\n    // because that means it will start a new \"section\" in the selector.\n    if (a.type === \"combinator\" ^ z.type === \"combinator\") {\n        return 0;\n    }\n    // One of the items is a pseudo and the other one isn't. Let's move\n    // the pseudo to the right.\n    if (a.type === \"pseudo\" ^ z.type === \"pseudo\") {\n        return (a.type === \"pseudo\") - (z.type === \"pseudo\");\n    }\n    // Both are pseudo's, move the pseudo elements (except for\n    // ::file-selector-button) to the right.\n    return isPseudoElement(a) - isPseudoElement(z);\n}\nfunction isPseudoElement(node) {\n    if (node.type !== \"pseudo\") return false;\n    if (pseudoElementExceptions.includes(node.value)) return false;\n    return node.value.startsWith(\"::\") || pseudoElementsBC.includes(node.value);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}