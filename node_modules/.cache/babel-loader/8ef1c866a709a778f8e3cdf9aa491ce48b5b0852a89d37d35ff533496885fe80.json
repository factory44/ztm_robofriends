{"ast":null,"code":"// @ts-check\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports,\n// DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\"default\", {\n  enumerable: true,\n  get: () => setupTrackingContext\n});\nconst _fs = /*#__PURE__*/_interopRequireDefault(require(\"fs\"));\nconst _quickLru = /*#__PURE__*/_interopRequireDefault(require(\"quick-lru\"));\nconst _hashConfig = /*#__PURE__*/_interopRequireDefault(require(\"../util/hashConfig\"));\nconst _getModuleDependencies = /*#__PURE__*/_interopRequireDefault(require(\"../lib/getModuleDependencies\"));\nconst _resolveConfig = /*#__PURE__*/_interopRequireDefault(require(\"../public/resolve-config\"));\nconst _resolveConfigPath = /*#__PURE__*/_interopRequireDefault(require(\"../util/resolveConfigPath\"));\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _parseDependency = /*#__PURE__*/_interopRequireDefault(require(\"../util/parseDependency\"));\nconst _validateConfigJs = require(\"../util/validateConfig.js\");\nconst _contentJs = require(\"./content.js\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n  let candidateFiles = (0, _contentJs.parseCandidateFiles)(context, tailwindConfig);\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n}\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n  if (userConfigPath !== null) {\n    let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n    let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map(dep => dep.file);\n    let modified = false;\n    let newModified = new Map();\n    for (let file of newDeps) {\n      let time = _fs.default.statSync(file).mtimeMs;\n      newModified.set(file, time);\n      if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n        modified = true;\n      }\n    }\n    // It hasn't changed (based on timestamps)\n    if (!modified) {\n      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];\n    }\n    // It has changed (based on timestamps), or first run\n    for (let file1 of newDeps) {\n      delete require.cache[file1];\n    }\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    newConfig = (0, _validateConfigJs.validateConfig)(newConfig);\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified]);\n    return [newConfig, userConfigPath, newHash, newDeps];\n  }\n  // It's a plain object, not a path\n  let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);\n  return [newConfig1, null, (0, _hashConfig.default)(newConfig1), []];\n}\nfunction setupTrackingContext(configOrPath) {\n  return _ref => {\n    let {\n      tailwindDirectives,\n      registerDependency\n    } = _ref;\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies);\n      // If there are no @tailwind or @apply rules, we don't consider this CSS\n      // file or its dependencies to be dependencies of the context. Can reuse\n      // the context even if they change. We may want to think about `@layer`\n      // being part of this trigger too, but it's tough because it's impossible\n      // for a layer in one file to end up in the actual @tailwind rule in\n      // another file since independent sources are effectively isolated.\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from);\n        // Add all css @import dependencies as context dependencies.\n        for (let message of result.messages) {\n          if (message.type === \"dependency\") {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n      let [context,, mTimesToCommit] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig);\n      // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n      // dependencies to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n      if (tailwindDirectives.size > 0) {\n        // Add template paths as postcss dependencies.\n        for (let contentPath of candidateFiles) {\n          for (let dependency of (0, _parseDependency.default)(contentPath)) {\n            registerDependency(dependency);\n          }\n        }\n        let [changedContent, contentMTimesToCommit] = (0, _contentJs.resolvedChangedContent)(context, candidateFiles, fileModifiedMap);\n        for (let content of changedContent) {\n          context.changedContent.push(content);\n        }\n        // Add the mtimes of the content files to the commit list\n        // We can overwrite the existing values because unconditionally\n        // This is because:\n        // 1. Most of the files here won't be in the map yet\n        // 2. If they are that means it's a context dependency\n        // and we're reading this after the context. This means\n        // that the mtime we just read is strictly >= the context\n        // mtime. Unless the user / os is doing something weird\n        // in which the mtime would be going backwards. If that\n        // happens there's already going to be problems.\n        for (let [path, mtime] of contentMTimesToCommit.entries()) {\n          mTimesToCommit.set(path, mtime);\n        }\n      }\n      for (let file of configDependencies) {\n        registerDependency({\n          type: \"dependency\",\n          file\n        });\n      }\n      // \"commit\" the new modified time for all context deps\n      // We do this here because we want content tracking to\n      // read the \"old\" mtime even when it's a context dependency.\n      for (let [path1, mtime1] of mTimesToCommit.entries()) {\n        fileModifiedMap.set(path1, mtime1);\n      }\n      return context;\n    };\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","setupTrackingContext","_fs","_interopRequireDefault","require","_quickLru","_hashConfig","_getModuleDependencies","_resolveConfig","_resolveConfigPath","_setupContextUtils","_parseDependency","_validateConfigJs","_contentJs","obj","__esModule","default","configPathCache","maxSize","candidateFilesCache","WeakMap","getCandidateFiles","context","tailwindConfig","has","candidateFiles","parseCandidateFiles","set","getTailwindConfig","configOrPath","userConfigPath","prevConfig","prevConfigHash","prevDeps","prevModified","newDeps","map","dep","file","modified","newModified","Map","time","statSync","mtimeMs","file1","cache","newConfig","validateConfig","newHash","newConfig1","config","undefined","_ref","tailwindDirectives","registerDependency","root","result","tailwindConfigHash","configDependencies","contextDependencies","Set","size","add","opts","from","message","messages","type","mTimesToCommit","getContext","fileModifiedMap","getFileModifiedMap","contentPath","dependency","changedContent","contentMTimesToCommit","resolvedChangedContent","content","push","path","mtime","entries","path1","mtime1"],"sources":["/Users/grzegorzlis/Visual_Projects/ztm_web_dev/folder17/robofriends/node_modules/tailwindcss/lib/lib/setupTrackingContext.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\"default\", {\n    enumerable: true,\n    get: ()=>setupTrackingContext\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(require(\"fs\"));\nconst _quickLru = /*#__PURE__*/ _interopRequireDefault(require(\"quick-lru\"));\nconst _hashConfig = /*#__PURE__*/ _interopRequireDefault(require(\"../util/hashConfig\"));\nconst _getModuleDependencies = /*#__PURE__*/ _interopRequireDefault(require(\"../lib/getModuleDependencies\"));\nconst _resolveConfig = /*#__PURE__*/ _interopRequireDefault(require(\"../public/resolve-config\"));\nconst _resolveConfigPath = /*#__PURE__*/ _interopRequireDefault(require(\"../util/resolveConfigPath\"));\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _parseDependency = /*#__PURE__*/ _interopRequireDefault(require(\"../util/parseDependency\"));\nconst _validateConfigJs = require(\"../util/validateConfig.js\");\nconst _contentJs = require(\"./content.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet configPathCache = new _quickLru.default({\n    maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\nfunction getCandidateFiles(context, tailwindConfig) {\n    if (candidateFilesCache.has(context)) {\n        return candidateFilesCache.get(context);\n    }\n    let candidateFiles = (0, _contentJs.parseCandidateFiles)(context, tailwindConfig);\n    return candidateFilesCache.set(context, candidateFiles).get(context);\n}\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n    let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n    if (userConfigPath !== null) {\n        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n        let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map((dep)=>dep.file);\n        let modified = false;\n        let newModified = new Map();\n        for (let file of newDeps){\n            let time = _fs.default.statSync(file).mtimeMs;\n            newModified.set(file, time);\n            if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n                modified = true;\n            }\n        }\n        // It hasn't changed (based on timestamps)\n        if (!modified) {\n            return [\n                prevConfig,\n                userConfigPath,\n                prevConfigHash,\n                prevDeps\n            ];\n        }\n        // It has changed (based on timestamps), or first run\n        for (let file1 of newDeps){\n            delete require.cache[file1];\n        }\n        let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n        newConfig = (0, _validateConfigJs.validateConfig)(newConfig);\n        let newHash = (0, _hashConfig.default)(newConfig);\n        configPathCache.set(userConfigPath, [\n            newConfig,\n            newHash,\n            newDeps,\n            newModified\n        ]);\n        return [\n            newConfig,\n            userConfigPath,\n            newHash,\n            newDeps\n        ];\n    }\n    // It's a plain object, not a path\n    let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n    newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);\n    return [\n        newConfig1,\n        null,\n        (0, _hashConfig.default)(newConfig1),\n        []\n    ];\n}\nfunction setupTrackingContext(configOrPath) {\n    return ({ tailwindDirectives , registerDependency  })=>{\n        return (root, result)=>{\n            let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n            let contextDependencies = new Set(configDependencies);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS\n            // file or its dependencies to be dependencies of the context. Can reuse\n            // the context even if they change. We may want to think about `@layer`\n            // being part of this trigger too, but it's tough because it's impossible\n            // for a layer in one file to end up in the actual @tailwind rule in\n            // another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                // Add current css file as a context dependencies.\n                contextDependencies.add(result.opts.from);\n                // Add all css @import dependencies as context dependencies.\n                for (let message of result.messages){\n                    if (message.type === \"dependency\") {\n                        contextDependencies.add(message.file);\n                    }\n                }\n            }\n            let [context, , mTimesToCommit] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n            let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);\n            let candidateFiles = getCandidateFiles(context, tailwindConfig);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n            // dependencies to be dependencies of the context. Can reuse the context even if they change.\n            // We may want to think about `@layer` being part of this trigger too, but it's tough\n            // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n            // in another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                // Add template paths as postcss dependencies.\n                for (let contentPath of candidateFiles){\n                    for (let dependency of (0, _parseDependency.default)(contentPath)){\n                        registerDependency(dependency);\n                    }\n                }\n                let [changedContent, contentMTimesToCommit] = (0, _contentJs.resolvedChangedContent)(context, candidateFiles, fileModifiedMap);\n                for (let content of changedContent){\n                    context.changedContent.push(content);\n                }\n                // Add the mtimes of the content files to the commit list\n                // We can overwrite the existing values because unconditionally\n                // This is because:\n                // 1. Most of the files here won't be in the map yet\n                // 2. If they are that means it's a context dependency\n                // and we're reading this after the context. This means\n                // that the mtime we just read is strictly >= the context\n                // mtime. Unless the user / os is doing something weird\n                // in which the mtime would be going backwards. If that\n                // happens there's already going to be problems.\n                for (let [path, mtime] of contentMTimesToCommit.entries()){\n                    mTimesToCommit.set(path, mtime);\n                }\n            }\n            for (let file of configDependencies){\n                registerDependency({\n                    type: \"dependency\",\n                    file\n                });\n            }\n            // \"commit\" the new modified time for all context deps\n            // We do this here because we want content tracking to\n            // read the \"old\" mtime even when it's a context dependency.\n            for (let [path1, mtime1] of mTimesToCommit.entries()){\n                fileModifiedMap.set(path1, mtime1);\n            }\n            return context;\n        };\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}